## Stolen from aapningstider.no by Stian Soiland (c) 2002
## stian@soiland.no

import exceptions, time, re, types, pprint

# You need to create this database module. 
# See the end of the Inspector doc-string.
import database

# from dynamic import DynamicFunction


def generateFromTables(tables, getLinks=1, code=1):
  """Generates python code (or class objects if code==0)
     based on SQL queries on the table names given in the list
     tables."""
  curs = database.cursor()
  inspectors = {}   
  for table in tables:
    # Define a  mini-class
    class inspector:
      pass
    # Register it, but capitalized name
    inspectors[table.capitalize()] = inspector
    inspector._sqlTable = table
    inspector._sqlLinks = {}
    inspector._sqlFields = {}  
    inspector._shortView = ()
    inspector._descriptions = {}
    inspector._userClasses = {}

    # Get columns
    curs.execute("SELECT * FROM %s LIMIT 1" % table)
    columns = [column[0] for column in curs.description]
    # convert to dictionary and register in inspector
    # Note that we mark the first column as the 'id'.
    # (this means that the first column could be
    #  twice in sqlFields - which is normal. Use 'id' for
    #  the primary key in code, and use the proper name
    #  when talking about the semantic value.
    inspector._sqlFields['id'] = columns[0]
    for column in columns:
      inspector._sqlFields[column] = column
    
  if getLinks:
    # Try to find links between tables (!)  
    # Note the big O factor with this ...

    for inspector in inspectors.values():
      for (key, column) in inspector._sqlFields.items():
        possTable = re.sub(r'_?id$', '', column)

        for candidate in inspectors.keys():
          if candidate.lower() == possTable.lower():
            # Woooh! First - let's replace 'blapp_id' with 'blapp'
            # as the attribute name to indicate that it would
            # contain the Blapp instance, not just 
            # some ID.
            del inspector._sqlFields[candidate]
            inspector._sqlFields[possTable] = column

            # And.. we'll need to know which class
            inspector._sqlLinks[possTable] = candidate
            
            break
  if code:
    print '''
"""Database inspectors.
Autogenerated by inspectors.generate() %s.
"""

import inspectors    

class _Wrapper(inspectors.Inspector):
    """Just a simple wrapper class so that you may
    easily change stuff for all inspectors. Typically
    this involves subcliassing MysqlInspector instead."""
    pass


''' % time.strftime('%Y-%m-%d')
    for (name, inspector) in inspectors.items():
      print "class %s(_Wrapper):" % name
      for (key, value) in inspector.__dict__.items():
        if key.find('__') == 0:
          continue
        nice = pprint.pformat(value)
        # Get some indention
        nice = nice.replace('\n', '\n       ' + ' '*len(key))
        print '    %s = ' % key, nice
      print ""  
    print '''

# Prepare them all. We need to send in our local
# namespace.
inspectors.prepareClasses(locals())
'''
  else:      
    # We wan't the actual classes. Let's go for it! 
    for (name, inspector) in inspectors.items():
      # Do this magic to include both our settings
      # and the normal Inspector stuff.
      class Spector(inspector, Inspector):
        """Automagically created by inspector."""
        pass
      Spector.__name__ = name  
      inspectors[name] = Spector
    prepareClasses(inspectors)  
    return inspectors
      

def prepareClasses(locals):
  """Fix _userClasses and some stuff in classes.
    Traverses locals, which is a locals() dictionary from
    the namespace where Inspector subclasses have been 
    defined, and resolves names in _userClasses to real
    class-references.

    Normally you would call inspector.prepareClasses(locals())
    after defining all classes in your local module.
    prepareClasses will only touch objects in the name space
    that is a subclassed of Inspector."""
  for (name, inspector) in locals.items():
    if not (type(inspector) is  types.ClassType  and
            issubclass(inspector, Inspector)):
      # Only care about Inspector objects
      continue
      
    # Resolve classes  
    for (key, userclass) in inspector._userClasses.items():
      if type(userclass) is types.StringType:
        # resolve from locals
        resolved = locals[userclass]
        inspector._userClasses[key] = resolved
        
    inspector._tables = {}  
    # Update all fields with proper names
    for (field, sqlfield) in inspector._sqlFields.items():
      inspector._sqlFields[field] = inspector._checkTable(sqlfield)
   
    newLinks = []
    for linkpair in inspector._sqlLinks:
      (link1, link2) = linkpair
      link1=inspector._checkTable(link1)
      link2=inspector._checkTable(link2)
      newLinks.append((link1, link2))

    inspector._sqlLinks = newLinks  
    inspector._prepared = 1

class NotFound(exceptions.Exception):
  pass

class Inspector:
  """Sql to object database inspector. 
  Given a welldefined database, by subclassing Inspector
  and supplying some attributes, you may wrap your SQL tables
  into objects that are easier to program with. 

  You must define all fields in the database table that you want
  to expose, and you may refine the names to suit your
  object oriented programming style. (ie. customerID -> customer)

  Objects will be created without loading from database, 
  loading will occur when you try to read or write some of the
  attributes defined as a SQL field. If you change some attributes the
  object will be saved to the database by save() or garbage
  collection. (be aware that GC in Py >= 2.2 is not immediate)

  If you want to create new objects, just supply them with blank
  ID-fields, and _nextSequence() will be called to fetch a new
  ID used for insertion.

  The rule is one class pr. table, although it is possible
  to join several table into one class, as long as the 
  identificator is unique. 

  By defining _userClasses you can resolve links to other
  tables, a field in this table would be an id in another
  table, ie. another class. In practical use this means that
  behind attributes pointing to other classes (tables)
  you will find instances of that class.

  Short example usage of inspectorobjects:
  
  # Process all
  for user in User.getAllIterator():
    print user.name
    print "Employed at:"
    print user.employed.name, user.employed.address
    user.employed = None # fire him
  
  # Retrieve some ID
  shop = Shop(552)
  shop.name = 'Corrected name'
  shop.save()   # Not neccessary, called at garbage collection
  
  # Include SQL where statements in selections
  myIDs = User.getAllIDs(("name='soiland'", 'salary > 5'))
  

  Requirements: A module named 'database' exporting the method
                cursor(), which should obviously return a cursor.
                The cursor should be DB 2.0 complient, preferably
                with autocommit turned on. (Transactions are not
                within the scope of this module yet)

                A sample database.py which takes care of restoring
                connections and so on is included for your 
                convenience.

                Python 2.2 (iterators, methodclasses)
  """
  # Will be 1 once prepare() is called
  _prepared = 0

  # The default table containing our fields
  # _sqlTable = 'shop'
  _sqlTable = ''

  # A mapping between our fields and the database fields.
  # 
  # You must include all fields needed here. You may specify 
  # other names if you want to make the sql name more approriate
  # for object oriented programming. (Like calling a field 'location' 
  # instead of 'location_id', because we wrap the location in a seperate
  # object and don't really care about the id)
  # 
  # You may reference to other tables with a dot, all
  # other db fields will be related to _sqlTable.
  # 
  # Note that 'id' field MUST be defined unless
  # _sqlPrimary is redefined.
  # 
  #  _sqlFields = {
  #    'id':   'shop_id',
  #    'name': 'name',
  #    'location': 'location_id',
  #    'chain': 'shop_chain_id',
  #    'address': 'address.address_id',
  #  }
  _sqlFields = {}

  # A list of attribute names (in the object, not database)
  # that are the primary key in the database. Normally
  # 'id' is sufficient.
  _sqlPrimary = ('id',)
  
  # When using other tables, you should include a
  # 'link' statement, displaying which fields link the
  # two tables together. Note that these are sql names.
  # NOTE: Don't forget the trailing , in the inner tupple
  #  _sqlLinks = (
  #    ('shop_id', 'address.shop_id'),
  #  )
  _sqlLinks = ()

  # Order by this field, if specified
  # _orderBy = 'id'
  _orderBy = None

  # _userClasses can be used to trigger creation of a field 
  # with an instance of the class. The given database field
  # will be sent to the constructor as an objectID
  # (ie. as self.id in this object) (ie. the class does not
  # neccessary need to be a subclass of Inspector)
  #
  # This means that the attribute will be an instance of that
  # class, not the ID. The object will not be loaded from the
  # database until you try to read any of it's attributes, 
  # though. (to prevent unneccessary database overload and
  # recursions)
  # 
  # Notice that _userClasses must be a name resolvable, ie. 
  # from the same module as your other classes.
  #  _userClasses = {
  #    'location': 'Location',
  #    'chain': 'Chain',
  #    'address': 'Address',
  #  }
  _userClasses = {}

  # If you want userClasses to work properly, you must also
  # 'prepare' your classes to resolve the names. This must be
  # done from the same module you are defining the classes:
  #   inspector.prepareClasses(locals())

  # A list of fields that are suitable for a textual 
  # representation (typical a one liner). 
  # 
  # Fields will be joint together with spaces or
  # simular.
  # _shortView = ('name')
  _shortView = ()
 
  # Description for the fields (ie. labels)
  # Note that these fields will be translated with the _ function.
  # If a field is undescribe, a capitalized version of the field name
  # will be presented.
  #_descriptions = {
  #  'name': 'Full name',
  #  'description': 'Description of thingie',
  #}
  _descriptions = {}

  
  def __init__(self, id=None):
    """Initialize, possibly with a database id. 
    Note that the object will not be loaded before you call load()."""
    self._values = {}
    self.reset()
    if id is None:
      self._resetID()
    else:  
      self._setID(id)
  def _setID(self, id):
    """Sets the ID, id can be either a list, following the
       _sqlPrimary, or some other type, that will be set
       as the singleton ID (requires 1-length sqlPrimary).
       
       Note that this means you cannot have tupples as
       primary keys directly into the database unless you
       double pack then, ie dirty one:
         _setID(((1,2),))
       (I don't think anyone want's tupple fields in their database
       as a primary key, though)
       """
    if type(id) in (types.ListType, types.TupleType):
      try:
        for key in self._sqlPrimary:
          value = id[0]
          self.__dict__[key] = value
          id = id[1:] # rest
      except IndexError:
        raise 'Not enough id fields, required: %s' % len(self._sqlPrimary)
    elif len(self._sqlPrimary) <= 1:
      # It's a simple value
      key = self._sqlPrimary[0]
      self.__dict__[key] = id
    else:
      raise 'Not enough id fields, required: %s' % len(self._sqlPrimary)
      
  def _getID(self):
    """Gets the ID values as a tupple annotated by sqlPrimary"""
    return [self.__dict__[key] for key in self._sqlPrimary]

  def _resetID(self):  
    """Resets all ID fields."""
    # Dirty.. .=))
    self._setID((None,) * len(self._sqlPrimary))

  def _validID(self):
    """Is all ID fields with values, ie. not None?"""
    return not None in self._getID()
  
  def __getattr__(self, key):
    """Will be called when an unknown key is to be
       retrieved, ie. most likely one of our database
       fields."""
    if self._sqlFields.has_key(key):
      if not self._updated:
        self.load()
      return self._values[key]
    else:
      raise AttributeError, key
      
  def __setattr__(self, key, value):
    """Will be called whenever something needs to be set, so
       we store the value as a SQL-thingie unless the key
       is not listed in sqlFIelds."""
    if key not in self._sqlPrimary and self._sqlFields.has_key(key):
      if not self._updated:
        self.load()
      self._values[key] = value
      self._changed = time.time()
    else:
      # It's a normal thingie
      self.__dict__[key] = value
  
  def __del__(self):
    """Saves the object on deletion. Be aware of this. If
       you want to undo some change, use reset() first.
       
       Be aware of Python 2.2's garbage collector, that
       might run in the background. This means that
       unless you call save() changes might not
       be done immediately in the database.

       Not calling save() also means that you cannot catch
       errors caused by wrong insertion/update (ie. wrong
       datatype for a field)
       """
    try:
      self.save()
    except Exception, e:
      pass
  
  def _checkTable(cls, field):
    """Splits a field from _sqlFields into table, column.
       Registers the table in cls._tables, and returns
       a fully qualified table.column 
       (default table: cls._sqlTable)"""
    # Get table part
    try:
      (table, field) = field.split('.')
    except ValueError:
      table = cls._sqlTable
    # clean away white space 
    table = table.strip()
    field = field.strip()
    # register table
    cls._tables[table] = None
    # and return in proper shape
    return table + '.' + field

  _checkTable = classmethod(_checkTable)  

  def reset(self):
    """Reset all fields, almost like creating a new object.
    Note: Forgets changes you have made not saved to database!
    (Remember: Others might reference the object already, 
    expecting something else!)
    Override this method if you add properties
    not defined in _sqlFields"""
    self._resetID()
    self._updated = None
    self._changed = None
    self._values = {}
    # initially create fields
    for field in self._sqlFields.keys():
      self._values[field] = None

  def load(self, id=None):
    """Loads from database if neccessary."""
    if not id is None:
      self.reset()
      self._setID(id)
    if self._validID():  
      self._loadDB()
    self._updated = time.time()
  
  def save(self):
    if (self._validID() and self._changed) or (self._updated and self._changed > self._updated):
      # Don't save if we have not loaded existing data!
      self._saveDB()

  def delete(self):
    """Marks this object for deletion in the database. 
       The object will then be reset and ready for use 
       again with a new id."""
    (sql, ) = self._prepareSql("DELETE")
    curs = database.cursor()
    curs.execute(sql, self._getID())
    curs.close()
    self.reset()
    
  def _prepareSql(cls, operation="SELECT", where=None, selectfields=None):
    """Returns a sql for the given operation.
       Possible operations:
         SELECT     read data for this id
         SELECTALL  read data for all ids
         INSERT     insert data, create new id
         UPDATE     update data for this id
         DELETE     remove data for this id
         
       SQL will be built by data from _sqlFields, and will
       contain 0 or several %s for you to sprintf-format in later:

         SELECT --> len(cls._sqlPrimary)
         SELECTALL --> 0 %s
         INSERT --> len(cls._sqlFields) %s (including id)  
         UPDATE --> len(cls._sqlFields) %s (including id)
         DELETE --> len(cls._sqlPrimary)

       (Note: INSERT and UPDATE will only change values in _sqlTable, so
        the actual number of fields for substitutions might be lower
        than len(cls._sqlFields) )

       For INSERT you should use cls._nextSequence() to retrieve
       a new 'id' number. Note that if your sequences are not named
       tablename_primarykey_seq  (ie. for table 'blapp' with primary key
       'john_id', sequence name blapp_john_id_seq) you must give the sequence
       name as an optional argument to _nextSequence)

       Additional note: cls._nextSequence() MUST be overloaded
       for multi _sqlPrimary classes. Return a tupple.
       
       Return values will always be tuples:
         SELECT --> (sql, fields)
         SELECTALL -> sql, fields)
         INSERT -> (sql, fields)
         UPDATE -> (sql, fields)
         DELETE -> (sql,)  -- for consistency
       
       fields will be object properties as a list, ie. the keys from
       cls._sqlFields. The purpose of this list is to give the programmer
       an idea of which order the keys are inserted in the SQL, giving
       help for retreiving (SELECT, SELECTALL) or inserting for %s
       (INSERT, DELETE).

       Why? Well, the keys are stored in a hash, and we cannot be sure
       about the order of hash.keys() from time to time, not even with
       the same instance.

       Optional where-parameter applies to SELECT, SELECTALL and DELETE.
       where should be a list or string of where clauses.
       
      """   
    # Normalize parameter for later comparissions
    operation = operation.upper()
    # Convert where to a list if it is a string
    if type(where) in (types.StringType, types.UnicodeType):
      where = (where,)
    
    if operation in ('SELECT', 'SELECTALL'):
      # Get the object fields and sql fields in the same
      # order to be able to reconstruct later.
      fields = []
      sqlfields = []
      for (field, sqlfield) in cls._sqlFields.items():
        if selectfields is None or field in selectfields:
            fields.append(field)
            sqlfields.append(sqlfield)
      if not fields:
        raise "No fields defined, cannot create SQL"
        
      sql = "SELECT\n  "
      sql += ', '.join(sqlfields)  
      sql += "\nFROM\n  "
      tables = cls._tables.keys()
      if not tables:
        raise "REALITY ERROR: No tables defined"
      sql += ', '.join(tables)
      temp = ["%s=%s" % linkPair for linkPair in cls._sqlLinks]
      # this MUST be here.
      if operation <> 'SELECTALL':
        for key in cls._sqlPrimary:
          temp.append(cls._sqlFields[key] + "=%s")
      if where:
        temp += where
      if(temp):
        sql += "\nWHERE\n  "
        sql += ' AND\n  '.join(temp) 
      if operation == 'SELECTALL' and cls._orderBy:
        sql += '\nORDER BY\n  ' + cls._sqlFields[cls._orderBy]
      return (sql, fields)
        
    elif operation in ('INSERT', 'UPDATE'):
      if operation == 'UPDATE':
        sql = 'UPDATE %s SET\n  ' % cls._sqlTable
      else:
        sql = 'INSERT INTO %s (\n  ' % cls._sqlTable
        
      set = []
      fields = []
      sqlfields = []
      for (field, sqlfield) in cls._sqlFields.items():
        if operation == 'UPDATE' and field in cls._sqlPrimary:
          continue
        if sqlfield.find(cls._sqlTable + '.') == 0:
          # It's a local field, chop of the table part
          sqlfield = sqlfield[len(cls._sqlTable)+1:]
          fields.append(field)
          sqlfields.append(sqlfield)
          set.append(sqlfield + '=%s')
      if operation == 'UPDATE':
        sql += ',\n  '.join(set)    
        sql += '\nWHERE\n  '
        temp = []
        for key in cls._sqlPrimary:
          temp.append(cls._sqlFields[key] + "=%s")
          fields.append(key)
        sql += ' AND\n  '.join(temp) 
      else:
        sql += ',\n  '.join(sqlfields)
        sql += ')\nVALUES (\n  '
        sql += ',\n  '.join(('%s',) * len(sqlfields))
        sql += ')'
        
      return (sql, fields)
      
    elif operation == 'DELETE':
      sql = 'DELETE FROM ' + SELF._SQLTable + ' WHERE '
      if where:
        sql += " AND\n  ".join(where) 
      else:
        for key in cls._sqlPrimary:
          temp = []
          for key in cls._sqlPrimary:
            temp.append(cls._sqlFields[key] + "=%s")
            fields.append(key)
        sql += ' AND\n  '.join(temp) 
      return (sql, )      
    else:
      raise "Unknown operation", operation
      
  _prepareSql = classmethod(_prepareSql)
  
  def _nextSequence(cls, name=None):
    """Returns a new sequence number for insertion in self._sqlTable.
     Note that if your sequences are not named
     tablename_primarykey_seq  (ie. for table 'blapp' with primary key
     'john_id', sequence name blapp_john_id_seq) you must give the full 
     sequence name as an optional argument to _nextSequence)
    """
    if not name:
      # Assume it's tablename_primarykey_seq
      name = self._sqlFields['id'].replace('.','_') + '_seq'
      # Don't have . as a tablename or column name!
    curs = database.cursor()
    curs.execute("SELECT nextval('%s')" % name)
    value = curs.fetchone()[0]
    curs.close()
    return value

  _nextSequence = classmethod(_nextSequence)
 
  def _loadFromRow(self, result, fields):
    """Load from a database row, described by fields.
       fields should be the attribute names that 
       will be set. Note that userclasses will be
       created (but not loaded).  """
    position = 0
    for elem in fields:
      value = result[position]
      if value and self._userClasses.has_key(elem):
        userClass = self._userClasses[elem]
        # create an instance
        value = userClass(value)
        
      self._values[elem] = value
      position += 1

  def _loadDB(self):  
    """Connects to the database to load myself"""
    if not self._validID():
      raise NotFound, self._getID()
    (sql, fields) = self._prepareSql("SELECT")
    curs = database.cursor()
    curs.execute(sql, self._getID()) 
    result = curs.fetchone()
    curs.close()
    if not result:
      raise NotFound, self._getID()
    self._loadFromRow(result, fields)  
    self._updated = time.time()
  
  def _saveDB(self):
    """Inserts or updates into the database"""
    # We're a "fresh" copy now
    self._updated = time.time()
    if not self._validID():
      operation = 'INSERT'
      self._setID(self._nextSequence())
      # Note that we assign this ID to our self
      # BEFORE possibly saving any of our attribute
      # objects that might be new as well. This means
      # that they might have references to us, as long
      # as the database does not require our existence
      # yet.
      #
      # Since mysql does not have Sequences, this will
      # not work as smoothly there. See class 
      # MysqlInspector below.
    else:
      operation = 'UPDATE'
    (sql, fields) = self._prepareSql(operation)  
    values = []
    for field in fields:
      value = getattr(self, field)
      if isinstance(value, Inspector):
        # It's another object, we store only the ID
        if(value.id is None):
          # It's a new object too, it must be saved!
          value.save()
        value = value.id
      values.append(value)  
    cursor = database.cursor()
    cursor.execute(sql, values)
    # cursor.commit()
    cursor.close()
  
  def getAll(cls, where=None):
    """Retrieves all the objects, possibly matching
       the where list of clauses, that will be AND-ed. 
       This will not load everything out
       from the database, but will create a large amount
       of objects with only the ID inserted. 
       The data will be loaded from the objects
       when needed by the regular load()-autocall."""
    ids = cls.getAllIDs(where)
    # Instansiate a lot of them
    return [cls(id) for id in ids]
    
  getAll = classmethod(getAll)  
  
  def getAllIterator(cls, where=None, buffer=100, useObject=None):
    """Retrieves every object, possibly limitted by the where
       list of clauses that will be AND-ed). Since this an
       iterator is returned, only buffer rows are loaded
       from the database at once. This is useful if you need
       to process all objects. If useObject is given, this object
       is returned each time, but with new data.
       """ 
    (sql, fields) = cls._prepareSql("SELECTALL", where)
    curs = database.cursor()
    fetchedAt = time.time()
    curs.execute(sql)
    # We might start eating memory at this point
    
    def getNext(rows=[]):
      inspector = cls
      if not rows:
        rows += curs.fetchmany(buffer)
      if not rows:
        curs.close()
        return None
      row = rows[0]
      del rows[0]
      idPositions = [fields.index(key) for key in cls._sqlPrimary]
      ids = [row[pos] for pos in idPositions]
      if useObject:
        result = useObject
        result.reset()
        result._setID(ids)
      else:  
        result = inspector(ids)
      result._loadFromRow(row, fields)
      result._updated = fetchedAt
      return result
    
    return iter(getNext, None)

  getAllIterator = classmethod(getAllIterator)

  def getAllIDs(cls, where=None):
    """Retrives all the IDs, possibly matching the
       where clauses. Where should be some list of 
       where clauses that will be joined with AND). Note
       that the result might be tuples if this table
       has a multivalue _sqlPrimary."""
     
    (sql, fields) = cls._prepareSql("SELECTALL", where, cls._sqlPrimary)
    curs = database.cursor()
    curs.execute(sql)
    # We might start eating memory at this point
    rows = curs.fetchall()
    curs.close()
    result = [] 
    idPositions = [fields.index(key) for key in cls._sqlPrimary]
    for row in rows: 
      ids = [row[pos] for pos in idPositions]
      if len(idPositions) > 1:
        ids = tuple(ids)
      else:
        ids = ids[0]
      result.append((ids))
    return result  
    
  getAllIDs = classmethod(getAllIDs)

  def getAllText(cls, where=None, SEPERATOR=' '):
    """Retrieves a list of of all possible instances of this class. 
    The list is composed of tupples in the format (id, description) -
    where description is a string composed by the fields from
    cls._shortView, joint with SEPERATOR.

    """
    (sql, fields) = cls._prepareSql("SELECTALL", where)
    curs = database.cursor()
    curs.execute(sql)
    # We might start eating memory at this point
    rows = curs.fetchall()
    curs.close()
    result = []  
    idPositions = [fields.index(key) for key in cls._sqlPrimary]
    shortPos = [fields.index(short) for short in cls._shortView]
    for row in rows: 
      ids = [row[pos] for pos in idPositions]
      if len(idPositions) > 1:
        ids = tuple(ids)
      else:
        ids = ids[0]
      text = SEPERATOR.join([str(row[pos]) for pos in shortPos])
      result.append((ids, text))
    return result  

  getAllText = classmethod(getAllText)  
  
  def getChildren(self, inspector, field=None):
    """Returns the children that links to me. That means that I have
       to be listed in their _userClasses somehow. If field is
       specified, that field in my children is used as the pointer
       to me. Use this if you have multiple fields referring to
       my class."""
    if not field:
      for (i_field, i_class) in inspector._userClasses.items():
        if isinstance(self, i_class):
          field = i_field
    if not field:
      raise "No field found, check inspector's _userClasses"
    sqlname = inspector._sqlFields[field]  
    myID = self._getID()[0] # assuming single-primary !
    return inspector.getAll("%s='%s'" % (sqlname, myID))
    
  def __repr__(self):
    return self.__class__.__name__ + ' %s' % self._getID()
  
  def __str__(self):
    short = [str(getattr(self, short)) for short in self._shortView]
    text = ', '.join(short)
    return repr(self) + ': ' + text

class MysqlInspector(Inspector):
  """MYSQL-compatible Inspector"""
  def _saveDB(self):
    """Overloaded - we dont have nextval() in mysql"""
    # We're a "fresh" copy now
    self._updated = time.time()
    if not self._validID():
      operation = 'INSERT'
      self._resetID() # Ie. get a new one
    else:
      operation = 'UPDATE'
    (sql, fields) = self._prepareSql(operation)  
    values = []
    for field in fields:
      value = getattr(self, field)
      if isinstance(value, Inspector):
        # It's another object, we store only the ID
        if(value.id is None):
          # It's a new object too, it must be saved!
          value.save()
        value = value.id
      values.append(value)  
    cursor = database.cursor()
    cursor.execute(sql, values)
    # cursor.commit()

    # Here's the mysql magic to get the new ID
    self._setID(cursor.insert_id())
    cursor.close()


##  ## Example from aapningstider.no
##  class Shop(Inspector):
##    _sqlTable = 'shop'
##    _sqlFields = {
##      'id':   'shop_id',
##      'name': 'name',
##      'location': 'location_id',
##      'chain': 'shop_chain_id',
##  #    'address': 'address.address_id',
##    }
##  #  _sqlLinks = (
##  #    ('shop_id', 'address.shop_id'),
##  #  )
##    _userClasses = {
##      'location': 'Location',
##      'chain': 'Chain',
##  #    'address': 'Address',
##    }
##    _shortView = (
##      'name',
##    )
##    _descriptions = {
##      'name': 'Shop name',
##      'location': 'Location',
##      'chain': 'Part of shop chain',
##    }
##  
##  class Location(Inspector):  
##    _sqlTable = 'location'
##    _sqlFields = {
##       "id":      "location_id",
##       "name":    "name",
##       "partOf":  "partoflocation",
##    }
##    _userClasses = {
##      'partOf': 'Location',
##    }
##    _shortView = (
##      'name',
##    )
##    _orderBy = 'name'
##    _descriptions = {
##      'name': 'Name',
##      'partOf': 'Part of area',
##    }
##    
