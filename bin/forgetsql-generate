#!/usr/bin/env python

# $Id$

## Distributed under LGPL
## (c) Stian Søiland 2002-2004
## stian@soiland.no
## http://forgetsql.sourceforge.net/

__version__ = "0.9"

import exceptions, time, re, types, pprint, sys

import forgetSQL

# change this!
##import psycopg
##c = psycopg.connect(database="db", user="user", password="pass")
##cursor = c.cursor

try:
  True,False
except NameError:
  (True, False) = (1==1, 1==0)

def generateFromTables(tables, cursor, getLinks=1, code=1):
  """Generates python code (or class objects if code==0)
     based on SQL queries on the table names given in the list
     tables."""
  curs = cursor()
  forgetters = {}
  for table in tables:
    # capitalize the table name to make it look like a class 
    name = table.capitalize()
    # Define the class by instanciating the meta class to
    # the given name (requires Forgetter to be new style)
    forgetter = Forgetter.__class__(name, (Forgetter,), {})
    # Register it
    forgetters[name] = forgetter
    forgetter._sqlTable = table
    forgetter._sqlLinks = {}
    forgetter._sqlFields = {}  
    forgetter._shortView = ()
    forgetter._descriptions = {}
    forgetter._userClasses = {}

    # Get columns
    curs.execute("SELECT * FROM %s LIMIT 1" % table)
    columns = [column[0] for column in curs.description]
    # convert to dictionary and register in forgetter
    for column in columns:
      forgetter._sqlFields[column] = column
    
  if getLinks:
    # Try to find links between tables (!)  
    # Note the big O factor with this ...

    for (tableName, forgetter) in forgetters.items():
      for (key, column) in forgetter._sqlFields.items():
        # A column refering to another table would most likely
        # be called otherColumnID or just otherColumn. We'll 
        # lowercase below when performing the test.
        possTable = re.sub(r'_?id$', '', column)

        # all tables (ie. one of the forgetters) are candidates
        foundLink = False
        for candidate in forgetters.keys():
          if candidate.lower() == possTable.lower():
            if possTable.lower() == tableName.lower():
              # It's our own primary key!
              forgetter._sqlPrimary = (column,)
              break
              
            # Woooh! First - let's replace 'blapp_id' with 'blapp'
            # as the attribute name to indicate that it would
            # contain the Blapp instance, not just 
            # some ID.
            del forgetter._sqlFields[key]
            forgetter._sqlFields[possTable] = column

            # And.. we'll need to know which class we refer to
            forgetter._userClasses[possTable] = candidate
            break # we've found our candidate

  if code:
    print '''
"""Database wrappers.
Autogenerated by forgetSQL %s.
"""

import forgetSQL

class _Wrapper(forgetSQL.Forgetter):
    """Just a simple wrapper class so that you may
    easily change stuff for all forgetters. Typically
    this involves subcliassing MysqlForgetter instead."""

    # Remember to change the class function cursor() so that
    # it returns a cursor connected to the database.
    # 
    ## cursor = lambda: myDatabase.cursor()
    pass


''' % time.strftime('%Y-%m-%d')
    items = forgetters.items()
    items.sort()
    for (name, forgetter) in items:
      print "class %s(_Wrapper):" % name
      for (key, value) in forgetter.__dict__.items():
        if key.find('__') == 0:
          continue
        nice = pprint.pformat(value)
        # Get some indention
        nice = nice.replace('\n', '\n       ' + ' '*len(key))
        print '    %s = ' % key, nice
      print ""  
    print '''

# Prepare them all. We need to send in our local
# namespace.
forgetSQL.prepareClasses(locals())
'''
  else:      
    for (name, forgetter) in forgetters.items():
      forgetter.cursor = cursor
      # hehe.. fake it!    
      Spector.__name__ = name  
    forgetSQL.prepareClasses(forgetters)
    return forgetters
      
def main():    
    try:
        # Should 
        from optparse import OptionParser
    except ImportError:
        print >>sys.stderr, "optik 1.4.1 or Python 2.3 or later needed for command line usage"
        print >>sys.stderr, "Download optik from http://optik.sourceforge.net/"
        print >>sys.stderr, "or upgrade Python."
        sys.exit(1)
    
    parser = OptionParser(version="%prog " + __version__)
    parser.add_option("-t", "--tables", dest="tables",
                      help="read list of tables from FILE instead of stdin",
                      metavar="FILE")        
    parser.add_option("-o", "--output", dest="output",
                      help="write generated code to OUTPUT instead of stdout")
    parser.add_option("-m", "--dbmodule", dest="dbmodule",
                      help="database module to use")
    parser.add_option("-H", "--host", dest="host",
                      help="hostname of database server")
    parser.add_option("-d", "--database", dest="database",
                      help="database to connect to")
    parser.add_option("-u", "--username", dest="username",
                      help="database username")
    parser.add_option("-p", "--password", dest="password",
                      help="database password")

    (options, args) = parser.parse_args()
    if options.tables:
        try:
            file = open(options.tables)
        except IOError, e:
            print >>sys.stderr, "%s: %s" % (e.strerror, e.filename)
            sys.exit(2)
    else:
        file = sys.stdin        
    
    if options.output:
        try:
            output = open(output, "w")
        except IOError, e:
            print >>sys.stderr, "%s: %s" % (e.strerror, e.filename)
            sys.exit(3)
    else:
        output = sys.stdout        
            
    if not options.dbmodule:
        print >>sys.stderr, "Missing required option --dbmodule"        
        parser.print_help(file=sys.stderr)
        sys.exit(4)
        
    tables = file.read().split()
    generateFromTables(tables)

if __name__=='__main__':
    main()
